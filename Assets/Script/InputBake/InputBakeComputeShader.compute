#pragma kernel InputAttractBake

struct InputRepulseData
{
    float2 uvPosition;
    float width;
    float strengh;
};

struct InputAttractData
{
    float colorChannelId;
    float2 uvPosition;
};

RWTexture2D<float4> InputTexture;
int InputTextureWidth;
int InputTextureHeight;

RWTexture2D<float4> HeatTexture;
int HeatTextureWidth;
int HeatTextureHeight;

StructuredBuffer<InputRepulseData> InputRepulseDataBuffer;
int InputRepulseBufferCount = 0;

StructuredBuffer<InputAttractData> InputAttractDataBuffer;
int InputAttractBufferCount = 0;

float ComputeAttractValue(float2 pixelUV) {
    float maxDistance = 3.0; //distance is computed with the uvpos
    int maxIndex = 0;

    for (int i = 0; i < InputAttractBufferCount; i++) {
        float2 inputPoint = InputAttractDataBuffer[i].uvPosition;
        float xPow = pixelUV.x - inputPoint.x;
        float yPow = pixelUV.y - inputPoint.y;

        xPow = xPow * xPow;
        yPow = yPow * yPow;

        float currentDistance = xPow + yPow;

        if (currentDistance < maxDistance) {
            maxDistance = currentDistance;
            maxIndex = i;
        }
    }

    return InputAttractDataBuffer[maxIndex].colorChannelId;
}

float GetInputAreaValue(float2 inputUV, float2 pixelUV, float expansionValue) //uv 0-1
{
    float dist = abs(distance(inputUV, pixelUV));
    float areaValue = 1.0 - (dist / expansionValue);
    return areaValue;
}

float ExpandChannelValue(float channelValue, float2 pixelPosition) {
    if (channelValue > 0.1) {
        return channelValue;
    }

    float max = channelValue;
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            float searchValue = InputTexture[pixelPosition + float2(x, y)].x;
            if (searchValue > max) {
                max = searchValue;
            }
        }
    }
    return max - 0.01;
}

[numthreads(4,4,1)]
void InputAttractBake(uint3 id : SV_DispatchThreadID)
{
    float2 pixelUv = float2(id.x / (float)InputTextureWidth, id.y / (float)InputTextureHeight);

    float attractCode = ComputeAttractValue(pixelUv);

    //get repulse values 
    float repulseHeatValue = InputTexture[id.xy].x;

    for (int i = 0; i < InputRepulseBufferCount; i++) {
        InputRepulseData repulseData = InputRepulseDataBuffer[i];
        float areaValue = GetInputAreaValue(repulseData.uvPosition, pixelUv, repulseData.width);
        repulseHeatValue = max(repulseHeatValue, areaValue);
    }

    repulseHeatValue = repulseHeatValue - 0.01;


    int2 heatPixel = int2(pixelUv.x * HeatTextureWidth, pixelUv.y * HeatTextureHeight);
    if (HeatTexture[heatPixel].x > 0.85) {
        repulseHeatValue = ExpandChannelValue(repulseHeatValue, id.xy);
    }

    InputTexture[id.xy] = float4(repulseHeatValue, 0.0, attractCode, 1.0);
}

